#[derive(Default)]
struct Character{
    entity: Option<Entity>,
    i: usize,
    j: usize,
    direction: Direction,
}




#[derive(Component)]
enum Direction {
    Up,
    Down,
    Left,
    Right,
    LeftUp,
    LeftDown,
    RightUp,
    RightDown,
}

fn setup(mut commands: Commands, asset_server: Res<AssetServer>) {
    commands.spawn(Camera2dBundle::default());
    commands.spawn((
        SpriteBundle {
            texture: asset_server.load("placeholder1.png"),
            transform: Transform::from_xyz(100., 0., 0.),
            ..default()
        },
        Direction::Up,
    ));
}

/// The sprite is animated by changing its translation depending on the time that has passed since
/// the last frame.
fn sprite_movement(time: Res<Time>, mut sprite_position: Query<(&mut Direction, &mut Transform)>) {
    for (mut logo, mut transform) in &mut sprite_position {
        match *logo {
            Direction::Up => transform.translation.y += 150. * time.delta_seconds(),
            Direction::Down => transform.translation.y -= 150. * time.delta_seconds(),
            Direction::Right => transform.translation.x += 150. * time.delta_seconds(),
            Direction::Left => transform.translation.y -= 150. * time.delta_seconds(),
            Direction::RightUp => transform.translation.y += 150. * time.delta_seconds(),
            Direction::RightDown => transform.translation.y -= 150. * time.delta_seconds(),
        }

        if transform.translation.y > 200. {
            *logo = Direction::Down;
        } else if transform.translation.y < -200. {
            *logo = Direction::Up;
        }
    }
}

// control the game character
fn move_character(
    mut commands: Commands,
    keyboard_input: Res<Input<KeyCode>>,
    mut game: ResMut<Game>,
    mut transforms: Query<&mut Transform>,
    time: Res<Time>,
) {
    let mut directionX = 0.0;
    let mut directionY = 0.0;
        if keyboard_input.pressed(KeyCode::Up) {
            directionY += 1.0;
            direction = Direction::Up;
        }
        if keyboard_input.pressed(KeyCode::Down) {
            directionY -= 1.0;
            direction = Direction::Down;
        }
        if keyboard_input.pressed(KeyCode::Right) {
            directionX += 1.0;
            direction = Direction::Right;
        }
        if keyboard_input.pressed(KeyCode::Left) {
            directionX -= 1.0;
            direction = Direction::Left;
        }

        let new_character_position = paddle_transform.translation.x + direction * PADDLE_SPEED * TIME_STEP;


    // eat the cake!
    if let Some(entity) = game.bonus.entity {
        if game.player.i == game.bonus.i && game.player.j == game.bonus.j {
            game.score += 2;
            game.cake_eaten += 1;
            commands.entity(entity).despawn_recursive();
            game.bonus.entity = None;
        }
    }
}

fn player_movement(
    time: Res<Time>,
    mut input: ResMut<Input>,
    mut velocity: Mut<Velocity>,
    mut position: Mut<Position>,
) {
    let mut dx = 0.0;
    let mut dy = 0.0;

    // Update player velocity based on input
    if input.up {
        dy -= 1.0;
    }
    if input.down {
        dy += 1.0;
    }
    if input.left {
        dx -= 1.0;
    }
    if input.right {
        dx += 1.0;
    }

    // Normalize velocity so that player moves at a constant speed
    let speed = 2.0;
    let length = (dx.powi(2) + dy.powi(2)).sqrt();
    if length > 0.0 {
        dx /= length;
        dy /= length;
        velocity.dx = dx * speed;
        velocity.dy = dy * speed;
    }

    // Update player position based on velocity
    position.x += velocity.dx * time.delta_seconds;
    position.y += velocity.dy * time.delta_seconds;
}

fn player_animation(
    time: Res<Time>,
    input: Res<Input>,
    mut animation: Mut<Animation>,
) {
    // Update player animation
    animation.time_left -= time.delta_seconds;
    if animation.time_left <= 0.0 {
        animation.time_left = animation.duration;

        // if input.up {
        //     animation.sprite = asset_server.load("player_up.png").unwrap();
        // } else if input.down {
        //     animation.sprite = asset_server.load("player_down.png").unwrap();
        // } else if input.left {
        //     animation.sprite = asset_server.load("player_left.png").unwrap();
        // } else if input.right {
        //     animation.sprite = asset_server.load("player_right.png").unwrap();
        // }
    }
}

fn render_player(
    mut sprite: Mut<Sprite>,
    animation: Res<Animation>,
) {
    // Update player sprite
    sprite.texture = animation.sprite;
}